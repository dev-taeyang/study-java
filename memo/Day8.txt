* 추상 클래스(클레스는 원래 추상적이다. -> 추상적인 걸로는 필드로 접근할 수 없음.) -> 중가로가 없는 메소드를 추상메소드라고 함.(메모리에 안올려짐)
			// 중가로가 없는것 -> 구현이 안된거는 메모리에 올릴수 없음. -> 무조건 재정의를해야함(강제성)

	필드안에 구현이 안된 메소드가 선언되어 있는 클래스를 추상 클래스라고 한다.
	이 때 구현되지 않은 메소드를 추상 메소드라고 부른다.
	반드시 재정의를 통해 구현을 해야하지만 메모리에 할당되기 때문에
	"강제성"을 부여하기 위해서 추상 메소드로 선언한다.(반드시 재정의를 해야함.)

추상 클래스 선언 //
	abstract class 클래스명 {
		abstract 리턴 타입 메소드명(매개변수, ...);
		일반 메소드 선언 가능.
	}

---------------------------------------------------------------------------------------------------------------------------------

인터페이스(interface) : 틀(그대로 가져다가 쓰고 변형시키면 안됨) -> 추상클래스를 좀더 고도화 해서 만든 틀
	추상 클래스를 고도화 시킨 문법.
	상수와 추상메소드만 존재한다.
	구현은 지정한 클래스에서 진행하고, 인터페이스를 다른 클래스에 지정할 때에는 implements 키워드를 사용한다.
	

추상 클래스와 인터페이스 간의 관계
	인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되어서
	전부 다 구현해야 한다. 하지만 일반적인 상황에서는 모든 것이 아닌,
	필요한 메소드를 골라서 재정의해야한다.
	인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 바디를 만들어 놓는다면,
	강제성이 소멸되고 이 클래스를 상속받아서 필드를 구현한다면, 골라서 재정의할 수 있게 된다.
	이 때 중간에서 강제성을 없애주는 클래스를 추상클래스로 선언하기로 하며,
	추상클래스 이름 뒤에는 Adapter를 붙여서 목적을 알려준다.

	
------------------------------------------------------------------------------------------------------------------------------------------

마커 인터페이스 (Marker InterFace) -> 표시를 하는 인터페이스     ////////  다시 확인해보기 생성하는것부터
	클래스들을 그룹화하기 위한 목적으로 사용한다.
	인터페이스는 지정한 클래스의 부모이며, 모든 자식은 부모의 타입이므로
	마커 인터페이스를 지정 받은 클래스들이 하나의 타입으로 묶이게 된다.
	이름 뒤에 Marker를 붙여줘야 한다.


--------------------------------------------------------------------------------------------------------------------------------------
	
내부 클래스(Inner Class) // 두클래스가 상호작용이 있을 때 사용

	하나의 클래스에서 a작업과 b작업이 있을 때에는 따로 분리하여 클래스로 만들지 않고,
	클래스 안에 클래스를 선언하여 설계한다. 이 때 밖에 있는 클래스를 외부 클래스라고 하며,
	안에 선언된 클래스를 내부 클래스라고 한다. 외부 클래스가 메모리에 할당되어야
	내부 클래스를 객체화 할 수 있기 때문에 클래스를 숨기기 위해서 내부 클래스를 사용하기도 하며,
	이를 캡슐화 또는 은닉화(내부클래스 + Private)라고 한다. 내부 클래스는 외부 클래스의 필드이기 때문에
	외부 클래스의 필드를 자신의 필드처럼 가져다 사용할 수 있지만 상속관계는 아니기 때문에
	내부 클래스일지라도 extends를 통해 다른 클래스를 상속 받아서 사용할 수 있다.

익명 클래스(Anonymous Inner Class)
	이름이 없는 클래스이며, 구현되지 않은 필드를 구현하기 위해 일회성으로 생성되는 클래스이다.


----------------------------------------------------------------------------------------------------------------------------------

심화 실습(클래스 ~ 익명 클래스)  		//지점은 객체로 사용해야 됨!!

- 스타벅스 본사 클래스 선언 (등록하기 메소드 생성 메개체 : form(인터페이스) -> instance of로 검사) -> register(Form form)
- 본사 제출 양식 인터페이스 선언 (form)
- 건물 클래스 선언(main 메소드)

스타벅스 지점 오픈 시 본사에 양식을 작성하여 제출.
- 제출 양식에는 메뉴판(getMenu())과 판매 방식(sell(String menu)을 작성한다. ->form 인터페이스 내에 익명 클래스로 선언
- 강남점은 메뉴 그대로 판매 할 수 있어야 하고, 잠실점은 무료 나눔 행사중이다. (강남점은 익명클래스로 그대로 사용)
- 두 지점은 판매 방식이 다르기 때문에 무료나눔 행사중인 지점은 판매 방식이 따로 없다. 
  (익명클래스로 구현을 하면안되니 adapter사용해서 해야함.)


----------------------------------------------------------------------------------------------------------------------------------

다중 상속 (자바는 다중상속을 지원하지 않는다. -> 인터페이스 다중상속으로 대체)

	여러 부모 클래스를 상속하는 것을 다중 상속이라고 한다.
	JAVA는 모호성 때문에 다중 상속을 지원하지 않는다.
	하지만 JDK8버전 부터는 인터페이스에 default 메소드를 선언할 수 있으며,
	여러 개를 지정할 수 있는 인터페이스 특성상 다중 상속을 지원하는 것이나 다름이 없다.

모호성(ambiguity)
	하나의 자식이 여러 부모를 상속받을 떄 부모 필드에 동일한 이름의 필드가 있다면,
	어떤 부모의 필드인지 알수가 없다. 이를 모호성이라고 부름.
	
모호성 해결 방법
	- 상황1 : 두 개의 인터페이스 내에 이름과 매개 변수가 똑같은 메소드가 선언되어 있다.
	- 해결1 : 자식 클래스에서 재정의하여 사용한다. 
	원하는 부모의 필드에 접근하기 위해서는 재정의된 메소드에서  "부모명.super.필드명"을 작성한다.


	- 상황2 : 부모 클래스의 메소드와 인터페이스의 디폴트 메소드의 이름과 매개변수가 똑같이 선언되어 있다.
	- 해결2 : 부모 클래스의 메소드가 사용된다. // 다른클래스가 쓰고 싶으면 자식 클래스에서 재정의 한다.


--------------------------------------------------------------------------------------------------------------------------------------
(익명 클래스 중요!!!!) 무조건 마스터하기.

함수형 인터페이스(Functional interface) - 중간작업을 생략하고 함수부터 사용할 수 있는거.
	인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.
	이때 @FunctionalInterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언할 수 있도록 제한해야 한다.

	

람다식(Lambda Experssion)	(익명클래스 문법을 한줄로 마무리할 수 있는 문법 JDK8부터 사용할 수 있음) - 익명 메소드 , 함수형 인터페이스로 선언!
	이름이 없는 메소드로서 값처럼 사용이 가능하며, 매개변수로도 전달이 가능하다.
	함수형 인터페이스는 추상 메소드가 한 개만 선언되기 때문에 메소드 이름이 필요 없다.
	따라서 람다식을 익명 메소드(Anonymous Method)라고도 부른다.

람다식 문법
	1. (매개변수 형식 나열, ...) -> 리턴값;
	2. (매개변수 형식 나열, ...) -> {2개 이상의 문장 작성; return 리턴값;}
	3. 매개변수가 한개일 경우 소괄호 전부 생략 가능


----------------------------------------------------------------------------------------------
람다식 기초 실습(과제)

	PrintName 인터페이스 선언 // 함수형 인터페이스
	getFullName() 추상메소드 선언
	- 성과 이름을 받는다. // 따로 받음
	
	PrintNameTest 클래스 선언
	printFullName() 메소드 선언 // 외부에서 성따로 이름따로 받고 붙이는 거 까지 구현해야됨.
	- 외부에서 구현된 PrintName(매개변수)을 전달 받은 뒤 전체 이름을 출력. //먼저 익명클래스를 만들어보고 익명클래스 대신에 람다식을 사용

----------------------------------------------------------------------------------------------------

[심화 실습]
여러 개의 정수를 입력받아서 알맞는 덧셈, 뺄셈 결과를 확인하는 애플리케이션 제작

입력 예1) 7 + 35 - 9
출력 예1) 33

입력 예2) -9 + 8 + 10
출력 예2) 9

* "ABC".split("")은 [A][B][C] 3칸 문자열 배열로 리턴된다.
   "A,B,C".split(",")은 [A][B][C] 3칸 문자열 배열로 리턴된다.
   split("구분점")을 전달하면 문자열에서 동일한 구분점을 기준으로 문자열 값을 잘라낸 후 문자열 배열로 리턴한다.
   구분점을 여러 개 사용할 때에는 split("구분점|구분점")으로 사용하며, "+", "-"를 구분점으로 사용할 때에는 "\\+", "\\-"로 표현한다.
   예)"4 + 9".split("\\+")은 [4][9] 2칸 문자열 배열로 리턴

* 사용자가 정상적으로만 입력한다는 가정 하에 구현하도록 한다.
* 두 정수를 전달받은 후 int로 리턴하는 calc 추상메소드 선언(함수형 인터페이스 제작)
* 두 정수의 덧셈, 뺄셈을 구해주는 함수형 인터페이스를 리턴하는 static 메소드 선언(람다식 리턴)
* 전체 식을 전달받은 후 String[]로 리턴하는 getOpers 추상메소드 선언(함수형 인터페이스 제작)
* main메소드에 getOper를 람다식으로 구현
* 첫번째 정수가 음수일 경우 오류 해결


-------------------------------------------------------------------------------------------------------------
















	
		